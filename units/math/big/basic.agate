# SPDX-License-Identifier: MIT
# Copyright (c) 2022 Julien Bernard
#
# Basic arithmetic with arrays

def BASE = 0x80000000

def char_to_int(c) {
  if ('0' <= c && c <= '9') {
    return c.to_i - '0'.to_i
  }
  if ('a' <= c && c <= 'z') {
    return c.to_i - 'a'.to_i + 10
  }
  if ('A' <= c && c <= 'Z') {
    return c.to_i - 'A'.to_i + 10
  }
  System.abort("Unknown digit: %(c)")
}

class __Basic {
  static from_int(input) {
    def digits = Array.new(3, 0)
    digits[0] = input % BASE
    input = input / BASE
    digits[1] = input % BASE
    input = input / BASE
    assert(input < BASE, "input should be less than BASE.")
    digits[2] = input
    return .normalize(digits)
  }

  static from_string(input, base) {
    def digits = [ 0 ]
    for (c in input) {
      def digit = char_to_int(c)
      if (digit >= base) {
        System.abort("Digit '%(c)' is not compatible with base %(base)")
      }
      digits = .mul_short(digits, base)
      digits = .add(digits, [ digit ])
    }
    return digits
  }

  static add(lhs, rhs) {
    assert(lhs is Array, "lhs should be an Array.")
    assert(rhs is Array, "rhs should be an Array.")

    def size = Math.max(lhs.size, rhs.size)
    def digits = Array.new(size, 0)
    def carry = 0

    for (i in 0...size) {
      def xl = i < lhs.size ? lhs[i] : 0
      def xr = i < rhs.size ? rhs[i] : 0

      def sum = carry + xl + xr
      digits[i] = sum % BASE
      carry = sum / BASE
      assert(carry == 0 || carry == 1, "Carry should be 0 or 1.")
    }

    if (carry == 1) {
      digits.append(carry)
    }

    return .normalize(digits)
  }

  static sub(lhs, rhs) {
    assert(lhs is Array, "lhs should be an Array.")
    assert(rhs is Array, "rhs should be an Array.")
    assert(.cmp(lhs, rhs) >= 0, "lhs should be greater than rhs")

    def size = Math.max(lhs.size, rhs.size)
    def digits = Array.new(size, 0)
    def carry = 0

    for (i in 0...size) {
      def xl = i < lhs.size ? lhs[i] : 0
      def xr = i < rhs.size ? rhs[i] : 0

      if (xl >= xr + carry) {
        def difference = xl - xr - carry
        digits[i] = difference % BASE
        carry = difference / BASE
        assert(carry == 0 || carry == 1, "Carry should be 0 or 1.")
      } else {
        def difference = BASE + xl - xr - carry
        digits[i] = difference % BASE
        carry = 1 + (difference / BASE)
        assert(carry == 1, "Carry should be 1.")
      }
    }

    assert(carry == 0, "Carry should be 0.")
    return .normalize(digits)
  }

  static split(digits, n) {
    return (n < digits.size) ? [ digits[0...n], digits[n..-1] ] : [ digits, [ 0 ] ]
  }

  static mul_classic(lhs, rhs) {
    assert(lhs is Array, "lhs should be an Array.")
    assert(rhs is Array, "rhs should be an Array.")
    def size = lhs.size + rhs.size
    def digits = Array.new(size, 0)

    for (i in 0...lhs.size) {
      def carry = 0

      for (j in 0...rhs.size) {
        def product = lhs[i] * rhs[j] + carry
        def accum = digits[i + j] + product
        digits[i + j] = accum % BASE
        carry = accum / BASE
        assert(carry < BASE, "Carry should be less than BASE.")
      }

      if (carry > 0) {
        def j = i + rhs.size
        assert(j < digits.size, "Index out of bounds.")
        digits[j] = carry
      }
    }

    return .normalize(digits)
  }

  static mul_karatsuba(lhs, rhs) {
    assert(lhs is Array, "lhs should be an Array.")
    assert(rhs is Array, "rhs should be an Array.")
    def size = Math.max(lhs.size, rhs.size)

    if (size <= 50) {
      return .mul_classic(lhs, rhs)
    }

    def size2 = size / 2
    def sl = .split(lhs, size2)
    def sr = .split(rhs, size2)

    # 0 = least, 1 = most
    def c1 = .mul_karatsuba(sl[1], sr[1])
    def c3 = .mul_karatsuba(sl[0], sr[0])

    def suml = .add(sl[0], sl[1])
    def sumr = .add(sr[0], sr[1])
    def prod = .mul_karatsuba(suml, sumr)

    def c2 = .sub(.sub(prod, c1), c3)

    c2 = [ 0 ] * size2 + c2
    c1 = [ 0 ] * (2 * size2) + c1

    return .add(.add(c1, c2), c3)
  }

  static mul_short(lhs, rhs) {
    assert(lhs is Array, "lhs should be an Array.")
    assert(rhs is Int, "rhs should be an Int.")
    assert(0 <= rhs && rhs < BASE, "rhs should be in [0, BASE[.")
    def size = lhs.size
    def digits = Array.new(size + 1, 0)
    def carry = 0

    for (i in 0...size) {
      def prod = carry + lhs[i] * rhs
      digits[i] = prod % BASE
      carry = prod / BASE
    }

    assert(carry < BASE, "Carry shoud be less than BASE.")
    digits[size] = carry
    return .normalize(digits)
  }

  static mul(lhs, rhs) { .mul_karatsuba(lhs, rhs) }

  static div_short(lhs, rhs) {
    assert(lhs is Array, "lhs should be an Array.")
    assert(rhs is Int && 0 < rhs && rhs < BASE, "rhs should be an Int.")

    def size = lhs.size
    def quo = Array.new(size, 0)
    def rem = 0

    for (i in 0...size) {
      rem = rem * BASE + lhs[size - i - 1]
      quo[size - i - 1] = rem / rhs
      rem = rem % rhs
    }

    return [ quo, rem ]
  }

  static div(lhs, rhs) {
    assert(lhs is Array, "lhs should be an Array.")
    assert(rhs is Array, "rhs should be an Array.")
    assert(lhs[-1] != 0, "lhs should be normalized.")
    assert(rhs[-1] != 0, "lhs should be normalized.")

    if (.cmp(lhs, rhs) < 0) {
      return [ [ 0 ], lhs.to_a ]
    }

    if (rhs.size == 1) {
      def qr = .div_short(lhs, rhs[0])
      return [ .normalize(qr[0]), .normalize([ qr[1] ]) ]
    }

    def m = lhs.size
    def n = rhs.size
    def d = BASE / (rhs[-1] + 1)
    def u = .mul_short(lhs, d)

    if (u.size == m) {
      u.append(0)
    }

    assert(u.size == m + 1, "u should have a size of m + 1.")

    def v = .mul_short(rhs, d)
    assert(v.size == n, "v should have a size of n")

    def vm = v[-1]
    assert(vm >= BASE / 2, "")

    assert(m >= n, "m should be greater than n.")
    def k = m - n

    def quo = Array.new(k + 1, 0)

    for (i in 0..k) {
      def u0 = u[(k-i)..-1] # TODO: slice?
      def qh
      def rh

      if (u0[n] == vm) {
        qh = BASE - 1
        rh = u0[n] + u0[n - 1]
      } else {
        def x = u0[n] * BASE + u0[n - 1]
        qh = x / vm
        rh = x % vm
      }

      assert(n >= 2, "n should be greater than 2.")
      assert(n - 2 < v.size, "n should be less than the size of v.")
      assert(n - 2 < u0.size, "n should be less than the size of u0.")

      while (rh < BASE && qh * v[n - 2] > BASE * rh + u0[n - 2]) {
        qh = qh - 1
        rh = rh + vm
      }

      def qhv = .mul_short(v, qh)

      if (.cmp(u0, qhv) < 0) {
        qh = qh - 1
        qhv = .sub(qhv, v)
      }

      assert(.cmp(u0, qhv) >= 0, "")


      def u1 = .sub(u0, qhv)
      quo[k - i] = qh

      for (j in 0..n) {
        u[k - i + j] = (j < u1.size ? u1[j] : 0)
      }
    }

    def qr = .div_short(u, d)
    assert(qr[1] == 0, "")
    def rem = qr[0]

    return [ .normalize(quo), .normalize(rem) ]
  }

  static is_zero(digits) { digits.all {|n| n == 0 } }

  static cmp(lhs, rhs) {
    assert(lhs is Array, "lhs should be an Array.")
    assert(rhs is Array, "rhs should be an Array.")

    def size = Math.max(lhs.size, rhs.size)

    for (i in 0...size) {
      def index = size - i - 1
      def nl = index < lhs.size ? lhs[index] : 0
      def nr = index < rhs.size ? rhs[index] : 0

      if (nl > nr) {
        return 1
      } else if (nl < nr) {
        return -1
      }
    }

    return 0
  }

  static to_chars(digits, base) {
    def digit_chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".to_a
    assert(base < digit_chars.size, "Base should be less than %(digit_chars.size)")
    def chars = []
    while (!.is_zero(digits)) {
      def qr = .div_short(digits, base)
      chars.append(digit_chars[qr[1]])
      digits = qr[0]
    }
    return chars.reverse()
  }

  static to_i(digits) {
    def i = 0
    for (digit in digits) {
      i = i * BASE + digit
    }
    return i
  }

  static normalize(digits) {
    while (digits.size > 1 && digits[-1] == 0) {
      digits.erase(-1)
    }
    return digits
  }

}
